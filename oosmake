#!/bin/bash

# # WHAT IS THIS? #
#
# This wraps the `make` command in order to try to find the correct
# out-of-source build directory or non-recursive makefile for the current
# directory. It does this by using a recursive ascent algorithm, as shown in the
# following examples.
#
# Example 1:
#
#     $P/                         (no makefile in this directory)
#     $P/build/makefile
#
#  Running oosmake from $P is like running:
#     make -C $P/build
#
# Example 2:
#
#     $P/makefile
#
#  Running oosmake from $P is like running:
#     make
#
# Example 3:
#
#     $P/                         (no makefile in this directory)
#     $P/alpha/                   (no makefile in this directory)
#     $P/bravo/                   (no makefile in this directory)
#     $P/build/makefile
#     $P/build/alpha/makefile
#     $P/build/bravo/             (no makefile in this directory)
#
#   Running oosmake from $P is like running:
#     make -C $P/build
#
#   Running oosmake from $P/alpha is like running:
#     make -C $P/build/alpha
#
#   Running oosmake from $P/bravo is like running:
#     make -C $P/build
#
# Example 4:
#
#     $P/makefile
#     $P/build/makefile
#
#   Running oosmake from $P is like running "make" from the $P directory. (Same
#   as regular make--the out-of-source "build" directory is ignored.)
#
# Example 5:
#
#   Nested out-of-source directories lacking a makefile will be skipped.
#
#     $P/                         (no makefile in this directory)
#     $P/alpha/                   (no makefile in this directory)
#     $P/alpha/bravo/             (no makefile in this directory)
#     $P/build/makefile
#     $P/build/alpha/makefile
#     $P/build/alpha/bravo/       (no makefile in this directory)
#
#   Running oosmake from $P/alpha/bravo is like running:
#     make -C $P/build/alpha
#
#   Running oosmake from $P/alpha is like running:
#     make -C $P/build/alpha
#
# Example 5:
#
#   Non-recursive makefile
#
#     $P/makefile
#     $P/alpha/                   (no makefile in this directory)
#     $P/alpha/bravo              (no makefile in this directory)
#
#   Running oosmake from $P/alpha is like running:
#     make -C $P
#
#   Running oosmaek from $P/alpha/bravo is like running:
#     make -C $P
#
#
# = FEATURES AND LIMITATIONS =
#
# - All command line options are passed as-is to the sub-make process. This
# includes -C and -f, which will likely mess up what you're trying to do.
#
# - Out-of-source builds are detected by testing for the existence of well named
# makefiles--GNUmakefile, Makefile, or makefile. Thus, running "oosmake -f
# my-custom-makefile" in the directory where "my-custom-makefile" is located
# will fail to run make in the current directory because oosmake is looking for
# well named makefiles, not your custom-named makefile.
#
# - There's no limit to the number of nested subdirectories. The recursive
# ascent algorithm will continue until either a makefile is found or else the
# root file system directory ("/") is attempted. The guard against mistakenly
# running an out-of-project makefile is that the out-of-source build directory
# must match the ascent path. (See example #3 above.) This isn't failsafe, but
# it makes the chance of mistakenly running an out-of-project makefile less
# likely.

if test "" == "${OOSMAKE_BUILD_DIRS}"; then
	build_dirs="build"
else
	build_dirs="${OOSMAKE_BUILD_DIRS}"
fi
make_args=$@
makefiles="GNUmakefile Makefile makefile"
me=$(basename $0)

die() {
	echo "${me}: *** $@" 1>&2
	exit 1
}

# Returns 0 if the given directory has a makefile, else non-zero.
has_makefile() {
    for m in ${makefiles}; do
        if [ -f "$1/$m" ]; then
            return 0
        fi
    done
    return 1
}

run_make() {
	make ${make_args}
	exit $?
}

try_make() {
	dir="$1"
	if $(has_makefile "${dir}"); then
		cd "${dir}" && run_make
	fi
}

s="" # stack
while true; do

    try_make .

    # Try to find makefile in an out-of-source build directory. Try the
    # most-nested directory first, and ascend the build directory tree until the
    # working stack is empty.
    ws="$s" # working stack
    while [ true ]; do
        for d in ${build_dirs}; do
            try_make "$d/$ws"
        done
        if [ "$ws" == "." -o -z "$ws" ]; then
            break
        fi
        ws="$(dirname "$ws")"
    done

	# Ascend to the parent directory and try again.
	cur="$(pwd)"
    s="$(basename "$cur")/$s"
	cd ..
	if [ "$(pwd)" == "${cur}" ]; then
		exit 2 # no makefile found
	fi

done

